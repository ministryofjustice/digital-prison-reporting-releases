name: Generate Release History in README

on:
  workflow_dispatch:
  pull_request:
    branches: [ main ]
  push:
    branches:
      - '**'
    tags:
      - 'v*'

permissions:
  contents: read

jobs:
  release-history:
    if: ${{ github.actor != 'github-actions[bot]' }}
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    concurrency:
      group: release-history-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Checkout repository (full history + tags)
        uses: actions/checkout@v4
        with:
          # Tag push -> checkout default branch to write there
          # PR -> checkout PR head branch
          # Branch push -> checkout the branch itself
          ref: ${{ github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') && github.event.repository.default_branch || github.event.pull_request.head.ref || github.ref }}
          fetch-depth: 0
          fetch-tags: true
      - name: Fetch all tags (force)
        shell: bash
        run: |
          git fetch --tags --force --prune
      - name: List detected tags
        shell: bash
        run: |
          echo "Tags seen by CI:"
          git tag --sort=-creatordate | nl | sed -n '1,120p'

      - name: Build release history body (ASCII only)
        shell: bash
        run: |
          set -euo pipefail
          TAGS=$(git tag --sort=-creatordate | head -n 20)

          if [ -z "$TAGS" ]; then
            TABLE_ROWS="| - | - | No releases yet |"
          else
            TABLE_ROWS=""
            while IFS= read -r tag; do
              date=$(git log -1 --format=%as "$tag" 2>/dev/null || echo "-")
              subject=$(git for-each-ref "refs/tags/$tag" --format='%(subject)' 2>/dev/null || true)
              if [ -z "$subject" ]; then
                subject=$(git log -1 --pretty=%s "$tag" 2>/dev/null || echo "Release $tag")
              fi
              TABLE_ROWS="${TABLE_ROWS}\n| ${tag} | ${date} | ${subject} |"
            done <<< "$TAGS"
          fi

          {
            echo '| Version | Date       | Description |'
            echo '|---------|------------|-------------|'
            printf "%b\n" "$TABLE_ROWS"
          } > /tmp/release_body.md

      - name: Verify markers & preview
        shell: bash
        run: |
          set -euo pipefail
          grep -n '<!-- RELEASE_HISTORY_START -->' README.md
          grep -n '<!-- RELEASE_HISTORY_END -->' README.md
          echo "Preview:"
          head -n 10 /tmp/release_body.md || true

      - name: Inject Release History into README.md
        shell: bash
        run: |
          set -euo pipefail
          BODY=/tmp/release_body.md
          awk -v body="$BODY" '
            /<!-- RELEASE_HISTORY_START -->/ { print; while ((getline L < body) > 0) print L; close(body); skip=1; next }
            /<!-- RELEASE_HISTORY_END -->/   { print; skip=0; next }
            skip!=1 { print }
          ' README.md > README.tmp
          if ! cmp -s README.tmp README.md; then
            mv README.tmp README.md
            echo "README updated."
          else
            echo "No changes to README."
          fi

      - name: Commit & push README (only if changed)
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "ci: update Release History in README"
          file_pattern: README.md
          # If your org forces GITHUB_TOKEN read-only, provide a PAT:
          # token: ${{ secrets.REPO_PUSH_TOKEN }}
